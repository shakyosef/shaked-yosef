"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transliterate = void 0;
const rules_1 = require("./rules");
const schema_1 = require("./schema");
const havarotjs_1 = require("havarotjs");
const word_1 = require("havarotjs/dist/word");
/**
 *
 * @param schema
 * @returns syllable options passed into havarotjs
 * @description sanitizes the SylOpts of the schema so as to not pass in undefined
 */
const getSylOpts = (schema) => {
    const options = {};
    if ("longVowels" in schema)
        options.longVowels = schema.longVowels;
    if ("qametsQatan" in schema)
        options.qametsQatan = schema.qametsQatan;
    if ("sqnmlvy" in schema)
        options.sqnmlvy = schema.sqnmlvy;
    if ("wawShureq" in schema)
        options.wawShureq = schema.wawShureq;
    if ("article" in schema)
        options.article = schema.article;
    if ("allowNoNiqqud" in schema)
        options.allowNoNiqqud = schema.allowNoNiqqud;
    return options;
};
/**
 * transliterates Hebrew text
 *
 * @param text - a string or {@link https://charlesloder.github.io/havarot/classes/text.Text.html | Text} of Hebrew characters
 * @param schema - a {@link Schema} for transliterating the text
 * @returns a transliterated text
 *
 * @example Default
 * ```ts
 * import { transliterate } from "hebrew-transliteration";
 *
 * transliterate("אֱלֹהִים");
 * // "ʾĕlōhîm";
 * ```
 *
 * ---
 *
 * @remarks
 *
 * If no {@link Schema} is passed, then the package defaults to SBL's academic style
 *
 * You can pass in a partial schema that will modify SBL's academic style:
 *
 * ```ts
 * transliterate("שָׁלוֹם", { SHIN: "sh" })
 * // shālôm
 * ```
 *
 * ---
 *
 * If you need a fully custom schema, it is best to use the {@link Schema} constructor:
 *
 * ```ts
 * import { transliterate, Schema } from "hebrew-transliteration";
 *
 * const schema = new Schema({ ALEF: "'", BET: "B", ... QAMETS: "A", ... }) // truncated for brevity
 *
 * transliterate("אָ֣ב", schema)
 * // 'AB
 * ```
 *
 */
const transliterate = (text, schema) => {
    const transSchema = schema instanceof schema_1.Schema ? schema : new schema_1.SBL(schema !== null && schema !== void 0 ? schema : {});
    const newText = text instanceof havarotjs_1.Text ? text : new havarotjs_1.Text(text, getSylOpts(transSchema !== null && transSchema !== void 0 ? transSchema : {}));
    return newText.words
        .map((word) => {
        var _a, _b;
        let transliteration = (0, rules_1.wordRules)(word, transSchema);
        if (transliteration instanceof word_1.Word) {
            transliteration = word.syllables
                .map((s) => (0, rules_1.sylRules)(s, transSchema))
                .join((_a = transSchema.SYLLABLE_SEPARATOR) !== null && _a !== void 0 ? _a : "");
        }
        return `${transliteration}${(_b = word.whiteSpaceAfter) !== null && _b !== void 0 ? _b : ""}`;
    })
        .join("");
};
exports.transliterate = transliterate;
