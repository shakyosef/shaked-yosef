"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Word_text;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Word = void 0;
const syllabifier_1 = require("./utils/syllabifier");
const syllable_1 = require("./syllable");
const divineName_1 = require("./utils/divineName");
/**
 * [[`Text.text`]] is split at each space and maqqef (U+05BE) both of which are captured.
 * Thus, the string passed to instantiate each `Word` is already properly decomposed, sequenced, qamets qatan patterns converted to the appropriate unicode character (U+05C7), and holem-waw sequences corrected.
 */
class Word {
    constructor(text, sylOpts) {
        _Word_text.set(this, void 0);
        __classPrivateFieldSet(this, _Word_text, text, "f");
        const startMatch = text.match(/^\s*/g);
        const endMatch = text.match(/\s*$/g);
        this.whiteSpaceBefore = startMatch ? startMatch[0] : null;
        this.whiteSpaceAfter = endMatch ? endMatch[0] : null;
        this.sylOpts = sylOpts;
    }
    /**
     * @returns the word's text trimmed of any whitespace characters
     *
     * ```typescript
     * const text: Text = new Text("אֵיפֹה־אַתָּה מֹשֶה");
     * const words = text.words.map((word) => word.text);
     * words;
     * // [
     * //    "אֵיפֹה־",
     * //    "אַתָּה",
     * //    "מֹשֶׁה"
     * //  ]
     * ```
     */
    get text() {
        return __classPrivateFieldGet(this, _Word_text, "f").trim();
    }
    /**
     * @returns a one dimensional array of Syllables
     *
     * ```typescript
     * const text: Text = new Text("אֵיפֹה־אַתָּה מֹשֶה");
     * text.words[0].syllables;
     * // [
     * //    Syllable { original: "אֵי" },
     * //    Syllable { original: "פֹה־" }
     * //  ]
     * ```
     */
    get syllables() {
        if (/\w/.test(this.text) || this.isDivineName || this.isNotHebrew) {
            const syl = new syllable_1.Syllable(this.clusters);
            return [syl];
        }
        return (0, syllabifier_1.syllabify)(this.clusters, this.sylOpts);
    }
    /**
     * @returns a one dimensional array of Clusters
     *
     * ```typescript
     * const text: Text = new Text("אֵיפֹה־אַתָּה מֹשֶה");
     * text.words[0].clusters;
     * // [
     * //    Cluster { original: "אֵ" },
     * //    Cluster { original: "י" },
     * //    Cluster { original: "פֹ" },
     * //    Cluster { original: "ה־" }
     * //  ]
     * ```
     */
    get clusters() {
        const clusters = (0, syllabifier_1.makeClusters)(this.text);
        const firstCluster = clusters[0];
        const remainder = clusters.slice(1);
        firstCluster.siblings = remainder;
        return clusters;
    }
    /**
     * @returns a one dimensional array of Chars
     *
     * ```typescript
     * const text: Text = new Text("אֵיפֹה־אַתָּה מֹשֶה");text.words[0].chars;
     * // [
     * //    Char { original: "א" },
     * //    Char { original: "ֵ" }, (tsere)
     * //    Char { original: "פ" },
     * //    Char { original: "ֹ" }, (holem)
     * //    Char { original: "ה"},
     * //    Char { original: "־" }
     * //  ]
     * ```
     */
    get chars() {
        return this.clusters.map((cluster) => cluster.chars).flat();
    }
    /**
     * @returns a boolean indicating if the text is a form of the Divine Name
     *
     * ```typescript
     * const text: Text = new Text("יְהוָה");
     * text.words[0].isDivineName;
     * // true
     * ```
     */
    get isDivineName() {
        return (0, divineName_1.isDivineName)(this.text);
    }
    /**
     * @returns a boolean indicating if the word has a form of the Divine Name
     *
     * ```typescript
     * const text: Text = new Text("בַּֽיהוָ֔ה");
     * text.words[0].hasDivineName;
     * // true
     * ```
     */
    get hasDivineName() {
        return (0, divineName_1.hasDivineName)(this.text);
    }
    /**
     * Returns `true` if the Cluster does not have Hebrew chars
     */
    get isNotHebrew() {
        return !this.clusters.map((c) => c.isNotHebrew).includes(false);
    }
}
exports.Word = Word;
_Word_text = new WeakMap();
//# sourceMappingURL=word.js.map