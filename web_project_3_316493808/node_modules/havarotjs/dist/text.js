"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Text_original;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Text = void 0;
const word_1 = require("./word");
const qametsQatan_1 = require("./utils/qametsQatan");
const sequence_1 = require("./utils/sequence");
const holemWaw_1 = require("./utils/holemWaw");
const regularExpressions_1 = require("./utils/regularExpressions");
/**
 * `Text` is the main exported class.
 *
 */
class Text {
    /**
     * `Text` requires an input string,
     * and has optional arguments for syllabification,
     * which can be read about in the {@page Syllabification} page
     */
    constructor(text, options = {}) {
        _Text_original.set(this, void 0);
        this.options = this.setOptions(options);
        __classPrivateFieldSet(this, _Text_original, this.options.allowNoNiqqud ? text : this.validateInput(text), "f");
    }
    validateInput(text) {
        const niqqud = /[\u{05B0}-\u{05BC}\u{05C7}]/u;
        if (!niqqud.test(text)) {
            throw new Error("Text must contain niqqud");
        }
        return text;
    }
    validateOptions(options) {
        const validOpts = ["sqnmlvy", "longVowels", "wawShureq", "qametsQatan", "article", "allowNoNiqqud"];
        for (const [k, v] of Object.entries(options)) {
            if (!validOpts.includes(k)) {
                throw new Error(`${k} is not a valid option`);
            }
            if (typeof v !== "boolean") {
                throw new Error(`The value ${String(v)} is not a valid option for ${k}`);
            }
        }
        return options;
    }
    setOptions(options) {
        const schema = options.schema;
        return schema ? this.setSchemaOptions(schema) : this.setDefaultOptions(options);
    }
    setSchemaOptions(schema) {
        const schemaText = schema.toLowerCase();
        if (schemaText !== "traditional" && schemaText !== "tiberian") {
            throw new Error(`${schemaText} is not a valid schema`);
        }
        const traditionalOpts = { qametsQatan: true, sqnmlvy: true, longVowels: true, vavShureq: true };
        const tiberianOpts = { qametsQatan: false, sqnmlvy: true, longVowels: false, vavShureq: false };
        return schemaText === "traditional" ? traditionalOpts : tiberianOpts;
    }
    setDefaultOptions(options) {
        var _a, _b, _c, _d, _e, _f;
        options = this.validateOptions(options);
        return {
            sqnmlvy: (_a = options.sqnmlvy) !== null && _a !== void 0 ? _a : true,
            article: (_b = options.article) !== null && _b !== void 0 ? _b : true,
            longVowels: (_c = options.longVowels) !== null && _c !== void 0 ? _c : true,
            wawShureq: (_d = options.wawShureq) !== null && _d !== void 0 ? _d : true,
            qametsQatan: (_e = options.qametsQatan) !== null && _e !== void 0 ? _e : true,
            allowNoNiqqud: (_f = options.allowNoNiqqud) !== null && _f !== void 0 ? _f : false
        };
    }
    get normalized() {
        return this.original.normalize("NFKD");
    }
    get sanitized() {
        const text = this.normalized.trim();
        const sequencedChar = (0, sequence_1.sequence)(text).flat();
        const sequencedText = sequencedChar.reduce((a, c) => a + c.text, "");
        // split text at spaces and maqqef, spaces are added to the array as separate entries
        const textArr = sequencedText.split(regularExpressions_1.splitGroup).filter((group) => group);
        const mapQQatan = this.options.qametsQatan ? textArr.map(qametsQatan_1.convertsQametsQatan) : textArr;
        const mapHolemWaw = mapQQatan.map(holemWaw_1.holemWaw);
        return mapHolemWaw.join("");
    }
    /**
     * @returns the original string passed
     *
     * ```typescript
     * const text: Text = new Text("הֲבָרֹות");
     * text.original;
     * // "הֲבָרֹות"
     * ```
     */
    get original() {
        return __classPrivateFieldGet(this, _Text_original, "f");
    }
    /**
     * @returns a string that has been decomposed, sequenced, qamets qatan patterns converted to the appropriate unicode character (U+05C7), and holem-waw sequences corrected
     *
     * ```typescript
     * import { Text } from "havarotjs";
     * const text: Text = new Text("וַתָּשָׁב");
     * text.text;
     * // וַתָּשׇׁב
     * ```
     */
    get text() {
        return this.words.reduce((a, c) => { var _a; return `${a}${c.text}${(_a = c.whiteSpaceAfter) !== null && _a !== void 0 ? _a : ""}`; }, "");
    }
    /**
     * @returns a one dimensional array of Words
     *
     * ```typescript
     * const text: Text = new Text("הֲבָרֹות");
     * text.words;
     * // [Word { original: "הֲבָרֹות" }]
     * ```
     */
    get words() {
        const split = this.sanitized.split(regularExpressions_1.splitGroup);
        const groups = split.filter((group) => group);
        const words = groups.map((word) => new word_1.Word(word, this.options));
        return words;
    }
    /**
     * @returns a one dimensional array of Syllables
     *
     * ```typescript
     * const text: Text = new Text("הֲבָרֹות");
     * text.syllables;
     * // [
     * //    Syllable { original: "הֲ" },
     * //    Syllable { original: "בָ" },
     * //    Syllable { original: "רֹות" }
     * //  ]
     * ```
     */
    get syllables() {
        return this.words.map((word) => word.syllables).flat();
    }
    /**
     * @returns a one dimensional array of Clusters
     *
     * ```typescript
     * const text: Text = new Text("יָד");
     * text.clusters;
     * // [
     * //    Cluster { original: "יָ" },
     * //    Cluster { original: "ד" }
     * //  ]
     * ```
     */
    get clusters() {
        return this.syllables.map((syllable) => syllable.clusters).flat();
    }
    /**
     * @returns a one dimensional array of Chars
     *
     * ```typescript
     * const text: Text = new Text("יָד");
     * text.chars;
     * //  [
     * //    Char { original: "י" },
     * //    Char { original: "ָ" },
     * //    Char { original: "ד" }
     * //  ]
     * ```
     */
    get chars() {
        return this.clusters.map((cluster) => cluster.chars).flat();
    }
}
exports.Text = Text;
_Text_original = new WeakMap();
//# sourceMappingURL=text.js.map