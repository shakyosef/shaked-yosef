"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Syllable_clusters, _Syllable_isClosed, _Syllable_isAccented, _Syllable_isFinal;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Syllable = void 0;
/**
 * A `Syllable` is created from an array of [[`Clusters`]].
 */
class Syllable {
    /**
     *
     * @param clusters
     * @param param1
     *
     * See the {@page Syllabification} page for how a syllable is determined.
     * Currently, the Divine Name (e.g. יהוה), non-Hebrew text, and Hebrew punctuation (e.g. _passeq_, _nun hafucha_) are treated as a _single syllable_ because these do not follow the rules of Hebrew syllabification.
     */
    constructor(clusters, { isClosed = false, isAccented = false, isFinal = false } = {}) {
        _Syllable_clusters.set(this, void 0);
        _Syllable_isClosed.set(this, void 0);
        _Syllable_isAccented.set(this, void 0);
        _Syllable_isFinal.set(this, void 0);
        __classPrivateFieldSet(this, _Syllable_clusters, clusters, "f");
        __classPrivateFieldSet(this, _Syllable_isClosed, isClosed, "f");
        __classPrivateFieldSet(this, _Syllable_isAccented, isAccented, "f");
        __classPrivateFieldSet(this, _Syllable_isFinal, isFinal, "f");
    }
    /**
     * @returns a string that has been built up from the .text of its consituent Clusters
     *
     * ```typescript
     * const text: Text = new Text("וַיִּקְרָ֨א");
     * const sylText = text.syllables.map((syl) => syl.text);
     * sylText;
     * //  [
     * //    "וַ"
     * //    "יִּקְ"
     * //    "רָ֨א"
     * //  ]
     * ```
     */
    get text() {
        return this.clusters.reduce((init, cluster) => init + cluster.text, "");
    }
    /**
     * @returns a one dimensional array of Clusters
     *
     * ```typescript
     * const text: Text = new Text("וַיִּקְרָ֨א");
     * text.syllables[1].clusters;
     * // [
     * //    Cluster { original: "יִּ" },
     * //    Cluster { original: "קְ" }
     * //  ]
     * ```
     */
    get clusters() {
        return __classPrivateFieldGet(this, _Syllable_clusters, "f");
    }
    /**
     * @returns a one dimensional array of Chars
     *
     * ```typescript
     * const text: Text = new Text("וַיִּקְרָ֨א");
     * text.syllables[2].chars;
     * // [
     * //    Char { original: "ר" },
     * //    Char { original: "ָ" },
     * //    Char { original: "" }, i.e. \u{05A8} (does not print well)
     * //    Char { original: "א" }
     * //  ]
     * ```
     */
    get chars() {
        return this.clusters.map((cluster) => cluster.chars).flat();
    }
    /**
     * @returns true if Syllable is closed
     *
     * a closed syllable in Hebrew is a CVC or CVCC type, a mater letter does not close a syllable
     *
     * ```typescript
     * const text: Text = new Text("וַיִּקְרָ֨א");
     * text.syllables[0].isClosed; // i.e. "וַ"
     * // true
     * text.syllables[2].isClosed; // i.e. "רָ֨א"
     * // false
     * ```
     */
    get isClosed() {
        return __classPrivateFieldGet(this, _Syllable_isClosed, "f");
    }
    /**
     * @param closed a boolean for whether the Syllable is closed
     *
     * a closed syllable in Hebrew is a CVC or CVCC type, a _mater_ letter does not close a syllable
     */
    set isClosed(closed) {
        __classPrivateFieldSet(this, _Syllable_isClosed, closed, "f");
    }
    /**
     * @returns true if Syllable is accented
     *
     * an accented syllable receives stress
     *
     * ```typescript
     * const text: Text = new Text("וַיִּקְרָ֨א"); // note the taam over the ר
     * text.syllables[0].isAccented; // i.e. "וַ"
     * // false
     * text.syllables[2].isAccented; // i.e. "רָ֨א"
     * // true
     * ```
     */
    get isAccented() {
        return __classPrivateFieldGet(this, _Syllable_isAccented, "f");
    }
    /**
     * @param accented a boolean for whether the Syllable is accented
     *
     * an accented syllable receives stress
     */
    set isAccented(accented) {
        __classPrivateFieldSet(this, _Syllable_isAccented, accented, "f");
    }
    /**
     * @returns true if Syllable is final
     *
     * ```typescript
     * const text: Text = new Text("וַיִּקְרָ֨א");
     * text.syllables[0].isFinal; // i.e. "וַ"
     * // false
     * text.syllables[2].isFinal; // i.e. "רָ֨א"
     * // true
     * ```
     */
    get isFinal() {
        return __classPrivateFieldGet(this, _Syllable_isFinal, "f");
    }
    /**
     * @param final a boolean for whether the Syllable is the final Syallble
     */
    set isFinal(final) {
        __classPrivateFieldSet(this, _Syllable_isFinal, final, "f");
    }
}
exports.Syllable = Syllable;
_Syllable_clusters = new WeakMap(), _Syllable_isClosed = new WeakMap(), _Syllable_isAccented = new WeakMap(), _Syllable_isFinal = new WeakMap();
//# sourceMappingURL=syllable.js.map